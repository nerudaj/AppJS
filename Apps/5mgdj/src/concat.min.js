"use strict";

var version = '2.0.0';

'static'; var va = 1;
'static'; var vb = false;
/**
 *  \brief Cache for speeding up text-fit computations
 */
'static'; var vc = {}






// =============== //
// === METHODS === //
// =============== //
'static'; function fa() {
	vc = {};
}

/**
 *  @brief Get reference to DOM object by id
 */
'static'; function fb(id) {
	return document.getElementById(id);
}

'static'; function fc(id) {
	return document.getElementsByName(id);
}

/**
 *  @brief Display error message
 *  
 *  @param [in] module Origin module of message
 *  @param [in] func In which function message occured
 *  @param [in] message Message itself
 *  
 *  @details The message will be printed to console.error and
 *  also will be printed by alert. Alert printing can be supressed
 *  globally by setting va to 0.
 */
'static'; function fd(module, func, message) {
	var str = "ERROR: " + module + "::" + func + ": " + message;
	console.error(str);
	
	if(va > 0) alert(str);
}

/**
 *  @brief Get random number
 *  
 *  @param [in] min Minimum value(exclusive)
 *  @param [in] max Maximum value(exclusive)
 *  @return fe number
 */
'static'; function fe(min, max) {
	return Math.floor((Math.random() * max) + min);
}

/**
 *  @brief Assign default value to undefined argument
 *  
 *  @param [in] arg Argument to test
 *  @param [in] value Default value
 *  @return \p arg or \p value
 *  
 *  @details If \p arg is undefined then value is returned. Otherwise the \p arg is returned.
 */
'static'; function ff(arg, value) {
	return typeof arg !== "undefined" ? arg : value;
}

/**
 *  @brief How big the font should be to text fit the given boundaries
 *  
 *  @param [in] str Text that should fit
 *  @param [in] width Width of the bounding box
 *  @param [in] height Height of the bounding box
 *  @param [in] startSize From which fontSize the algorithm should start(Default: 100)
 *  @return Optimal font size
 *  
 *  @details This function does not take into account word breaking. Also, the algorithm looks for
 *  the first fontSize that fit, so if you're element is bigger than a text at fontSize 100, try
 *  tweaking the \p startSize to higher values like 500.
 *  
 *  For this to work, the html file must contain element with id 'HiddenResizer'. This element
 *  has to be span with visibility:hidden.
 */
'static'; function fg(str, width, height, startSize) {
	var fontSize = ff(startSize, 100);
	
	var resizer = fb("HiddenResizer");
	resizer.style.fontSize = fontSize + "px";
	
	resizer.innerHTML = str;
	var rw = resizer.offsetWidth;
	var rh = resizer.offsetHeight;
	
	while(rw > width * 0.8 || rh > height * 0.8) {
		fontSize -= 1;
		resizer.style.fontSize = fontSize + "px";
		rw = resizer.offsetWidth;
		rh = resizer.offsetHeight;
	}
	
	return fontSize;
}

// =============== //
// === aELEMENT === //
// =============== //
'static'; function fh() {
	this.dom = null; ///< DOM of the element
	this.width = 0; ///< Width of the element in pixels
	this.height = 0; ///< Height of the element in pixels
}

/**
 *  @brief Add sub element to element
 *  
 *  @param [in] x X coordinate, in %.
 *  @param [in] y Y coordinate, in %.
 *  @param [in] w Width of the element, in %.
 *  @param [in] h Height of the element, in %.
 *  @param [in] type Type of the element.(Default: div)
 *  @param [in] id ID of the DOM.(Default: none)
 *  @return Reference to new element
 *  
 *  @details Parent element defines the coordinate system for the subelement.
 *  All % values are numbers from 0 to 1. XY goes from topleft corner of the
 *  parent element. Example: To create an element that takes left half of the parent,
 *  use add(0, 0, 0.5, 1);
 */
fh.prototype.add = function(x, y, w, h, type, id) {
	type = ff(type, "div");
	id = ff(id, null);

	var result = new fh();

	var node = document.createElement(type);
	
	if(id != null) {
		node.setAttribute("id", id);
	}
	
	this.dom.appendChild(node);

	result.dom = node;
	result.width = this.width * w;
	result.height= this.height * h;

	result.dom.style.position = "absolute";
	result.dom.style.left = this.width * x + "px";
	result.dom.style.top = this.height * y + "px";
	result.dom.style.width = result.width + "px";
	result.dom.style.height = result.height + "px";
	
	if(type == 'input') {
		result.pd('focus', function() { vb = true; });
		result.pd('blur', function() { setTimeout(function() { vb = false; }, 500); });
	}

	return result;
}

/**
 *  @brief Set background color of an element
 *  
 *  @param [in] color Valid CSS string for color. You can use canonical names, hexa(#HHHHHH), hsl, rgb, ...
 */
'static'; fh.prototype.pa = function(color) {
	this.dom.style.background = color;
}

/**
 *  @brief Set text to the element
 *  
 *  @param [in] str Text
 *  @param [in] autofit Whether the text should autofit the element(Default: false)
 *  @param [in] startsize Starting fontSize for \ref fg.(Default: 100)
 *  
 *  @details If the text is not set to autofit, the fontSize is implicit and words can
 *  break.
 */
'static'; fh.prototype.pb = function(str, autofit, startSize) {
	autofit = ff(autofit, false);
	
	var fontSize = null;
	
	if(autofit) {
		startSize = ff(startSize, 100);
		fontSize = fg(str, this.width, this.height, startSize);
	}
	else if(startSize !== 'undefined') {
		fontSize = startSize;
	}
	
	var t = document.createTextNode(str);
	
	if(fontSize != null) {
		this.dom.style.fontSize = fontSize + "px";
	}
	
	this.dom.appendChild(t);
}

'static'; fh.prototype.pc = function(name) {
	this.dom.className += ' ' + name;
}

'static'; fh.prototype.pd = function(event, action) {
	this.dom.addEventListener(event, action);
}

// ============ //
// === VIEW === //
// ============ //
/**
 *  @brief Single page view of the application
 *  
 *  @details This object represents a single page of
 *  your application. Application can consist of many views.
 *  All views share the same canvas and when one is rendered,
 *  it deletes any data previously rendered to the canvas.
 *  
 *  When creating new view, placeholder \ref pe method is
 *  used. You are obligated to replace it with your own. Then
 *  you can access the drawing canvas with this.app.canvas
 *  and you can also access app's shared data with this.app.context.
 */
'static'; function fi() {
	this.app = null; ///< Reference to the app object
}

/**
 *  @brief Render this view
 *  
 *  @details This method is only a placeholder. Upon creating new
 *  view, you are obligated to set this.pe to your own callback.
 */
'static'; fi.prototype.pe = function() {
	fd("ClassView", "render", "This method is not implemented!");
}

/**
 *  @brief Bootstrap the view
 *  
 *  @param [in] canvas Reference to the \ref App object
 *  
 *  @details This method is called automatically by \ref App during \ref pg.
 */
'static'; fi.prototype.pf = function(app) {
	this.app = app;
}

// =========== //
// === APP === //
// =========== //
/**
 *  @brief Object representing app itself
 *  
 *  @details App consists of drawing canvas, shared context
 *  and a number of view between which you can freely toggle.
 */
'static'; function fj() {
	this.context = {}; ///< Shared application context. Any data that should be persistent has to be saved there
	this.canvas = new fh(); ///< Core drawing canvas
	this.views = {}; ///< Storage for views
	this.currentView = ""; ///< Index to current view
}

/**
 *  @brief Add new view to application
 *  
 *  @param [in] view \ref View object
 *  @param [in] name Name for the view(must be unique)
 *  @return TRUE on success, FALSE if view already exists
 *  
 *  @details View is bootstraped automatically if added
 *  successfully.
 */
'static'; fj.prototype.pg = function(view, name) {
	var views = this.views;
	
	if(views.hasOwnProperty(name)) {
		fd("ClassApp", "addView", "View with name " + name + " already exists!");
		return false;
	}
	
	views[name] = view;
	views[name].pf(this);
	
	return true;
}

/**
 *  @brief Change the rendered view
 *  
 *  @param [in] name Name of the view to change to
 *  
 *  @pre \ref pg with \p name was called
 */
'static'; fj.prototype.ph = function(name) {
	if(!this.views.hasOwnProperty(name)) {
		fd("ClassApp", "toggleView", "View called " + name + " does not exist!");
		return;
	}
	
	this.currentView = name;
	this.pe();
}

/**
 *  @brief Render app. Basically redraws currently selected view
 *  
 *  @details When app is redrawed it also recomputes viewport, so it will resize if needed
 */
'static'; fj.prototype.pe = function() {
	var canvas = this.canvas;
	
	// Clear everything rendered so far
	canvas.dom.innerHTML = "";
	
	// Resize canvas
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	
	canvas.dom.style.position = "absolute";
	canvas.dom.style.width = canvas.width + "px";
	canvas.dom.style.height = canvas.height + "px";
	
	// Render current view
	this.views[this.currentView].pe();
}

/**
 *  @brief Bootstrap the app
 *  
 *  @param [in] id ID of the core canvas DOM element
 *  
 *  @details This method should be called as the first
 *  thing in your program. It registers automatic resize
 *  of the app as well as it binds to drawing canvas.
 */
'static'; fj.prototype.pf = function(id) {
	this.canvas.dom = fb(id);
	
	var that = this;
	window.addEventListener('resize', function() {
		if(vb) return;
		fa();
		that.pe();
	});
};'static'; var vd = [
	'Resource Management',
	'Lives',
	'Tile Placement',
	'Score',
	'Evasion',
	'Reflexes',
	'Shooting',
	'Role Playing',
	'Looting',
	'Exploration',
	'Driving',
];
'static'; var ve = [
	'Dice',
	'Card',
	'Hexes',
	'Cube',
	'Quests',
	'No Enemies',
	
];

'static'; function fk() {
	var canvas = this.app.canvas;
	
	fv(canvas, 'XX:XX');
	
	var board = fw(canvas);
	
	// Labels
	fl(board, 0, 'Pattern:', vd);
	fl(board, 0.1, 'Restriction:', ve);
	fl(board, 0.2, 'Modifier:', vd.concat(ve));
	
	// Create textbox
	var text = board.add(0.05, 0.35, 0.9, 0.6, 'textarea', 'a');
	
	var buttons = [
		new fs('Stop', function() {
			fo(app);
		}),
		new fs('Submit', function() {}),
		new fs('Back', function() {
			fo(app);
			app.ph(0);
		})
	];
	fu(canvas, buttons, 'b');
	
	if(this.app.context.handle == null) {
		fm(this.app);
	}
}

'static'; function fl(canvas, yoffset, labelstr, array) {
	console.log(array);
	// TODO: fontCache
	
	var label = canvas.add(0, yoffset, 0.4, 0.1);
	label.pb(labelstr, true);
	
	// Get random string
	var str = array[fe(0, array.length)];
	
	var text = canvas.add(0.4, yoffset, 0.6, 0.1);
	text.pb(str, true);
}

'static'; function fm(app) {
	var context = app.context;
	
	context.timer = 5 * 60;
	
	context.handle = setInterval(function() {
		fn(app);
	}, 1000);
}

'static'; function fn(app) {
	var context = app.context;
	
	context.timer--;
	if(context.timer == 0) {
		fb('c').innerHTML = 'END!';
		fo(app);
		return;
	}
	
	fp(context.timer);
}

'static'; function fo(app) {
	var context = app.context;
	
	clearInterval(context.handle);
	context.handle = null;
}

'static'; function fp(value) {
	// TODO: Format
	fb('c').innerHTML = value;
};// Global variables
var app = new fj();

// Bootstrap app
function Main() {
	// Bootstrap app
	app.pf('Canvas');

	// Setup app context
	app.context['handle'] = null;
	app.context['timer'] = 0;

	// Setup views
	var views = [
		{ callback: fq, name: 0 },
		{ callback: fk, name: 1 }
	];
	
	// Add views to app
	for(var i = 0; i < views.length; i++) {
		var view = new fi();
		view.pe = views[i].callback;
		app.pg(view, views[i].name);
	}
	
	// Toggle default view
	app.ph(0);
};'static'; function fq() {
	var canvas = this.app.canvas;
	
	fv(canvas, '5min Design Game Jam');
	
	var board = fw(canvas);
	board.pb('Hello world');
	
	var buttons = [
		new fs('Start the challenge', function() {
			app.ph(1);
		}),
	];
	fu(canvas, buttons, 'b');
};// *** CORE LAYOUT VALUES ***
'static'; var vf = 0.0807;
'static'; var vg = vf;

/**
 *  @brief Return longest of two strings
 *  
 *  @param [in] str1 First string
 *  @param [in] str2 Second string
 *  @return Longer of both strings
 */
'static'; function fr(str1, str2) {
	if(str1.length > str2.length) return str1;
	return str2;
}

/**
 *  @brief Create button for templater
 *  
 *  @param [in] label Label written on the button
 *  @param [in] action Function callback of the button
 *  @param [in] id Optional id assigned to the button
 */
'static'; function fs(label, action, id) {
	this.label = label;
	this.action = action;
	this.id = ff(id, null);
}

/**
 *  @brief Render array of buttons in parent canvas
 *  
 *  @param [in] canvas Destination canvas to render
 *  @param [in] buttons Array of ButtonTemplates
 *  @param [in] x X coordinate within canvas
 *  @param [in] y Y coordinate within canvas
 *  @param [in] w Width of button array within canvas
 *  @param [in] h Height of button array within canvas
 *  @param [in] cacheID ID to cache with fontsizes
 *  
 *  @details If any of the fields of \p buttons is null, that
 *  element will be skipped and blank space will be rendered instead.
 */
'static'; function ft(canvas, buttons, x, y, w, h, cacheID) {
	var BUTTON_WIDTH = w / buttons.length;

	if(vc[cacheID] == null) {
		var longestStr = '';
		for(var i = 0; i < buttons.length; i++) {
			longestStr = fr(longestStr, buttons[i].label);
		}

		vc[cacheID] = fg(
			longestStr,
			canvas.width * BUTTON_WIDTH,
			canvas.height * h
		);
	}

	for(var i = 0; i < buttons.length; i++) {
		if(buttons[i] == null) continue;
		(function(p) {
			var opt = canvas.add(x + i * BUTTON_WIDTH, y, BUTTON_WIDTH, h, 'button', buttons[p].id);
			opt.pd('click', buttons[p].action);
			opt.pb(buttons[p].label, false, vc[cacheID]);
			if(i > 0) opt.pc('button_separator');
		}(i));
	}
}

/**
 *  @brief Render app standard toolbar
 *  
 *  @param [in] parentCanvas Parent canvas that should contain toolbar
 *  @param [in] buttons Array of ButtonTemplates
 *  @param [in] cacheID ID for fontsize cache
 *  
 *  @details This function will create new container element positioned appropriately within parent canvas,
 *  set its style and background color and then pe buttons with \ref ft.
 *  
 *  Use this in conjunction with \ref fv and \ref fw.
 */
'static'; function fu(parentCanvas, buttons, cacheID) {
	var canvas = parentCanvas.add(0, 1 - vg, 1, vg);
	canvas.pc('toolbar');
	
	ft(canvas, buttons, 0, 0, 1, 1, cacheID);
}

/**
 *  @brief Render header of the view
 *  
 *  @param [in] canvas Parent canvas where header should be rendered
 *  @param [in] label Label of the header
 *  
 *  @details This creates new container within canvas, sets the text label, sets background color.
 *  Container will be positioned appropriately within parent canvas. All headers use the same cache ID.
 *  
 *  Use this in conjunction with \ref fu and \ref fw.
 */
'static'; function fv(canvas, label) {
	var header = canvas.add(0, 0, 1, vf, 'div', 'c');
	
	var cacheID = 'd';
	if(vc[cacheID] == null) {
		vc[cacheID] = fg(label, header.width, header.height);
	}
	
	header.pb(label, false, vc[cacheID]);
	header.pc('header');
}

/**
 *  @brief Get canvas for drawing view context(header and toolbar free)
 *  
 *  @param [in] core Core canvas where drawing canvas will be embedded
 *  @param [in] hasHeader Whether header is present in view
 *  @return Resulting canvas
 *  
 *  @details Use this in conjunction with \ref fu and \ref fv.
 */
'static'; function fw(core, hasHeader) {
	var HEADER_OFFSET = ff(hasHeader, true) ? vf : 0;
	var result = core.add(0, HEADER_OFFSET, 1, 1 - HEADER_OFFSET - vg);
	result.pc('content');
	return result;
};